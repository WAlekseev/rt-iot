---
layout: docwithnav
title: Узлы действий
description: Документация к IoT платформе Ростелеком
---
Узлы действий выполняют различные действия на основе входящего сообщения.

* TOC
{:toc}

# Узел Create Alarm


![image](/images/user-guide/rule-engine-2-0/nodes/action-create-alarm.png)

Этот узел пытается загрузить последний сигнал тревоги с настроенным **типом сигнала** для отправителя сообщения. Если существует **неочищенный** сигнал тревоги, то он будет обновлен, в противном случае будет создан новый.

Конфигурации узла:

- скрипт **Alarm Details Builder**
- **Тип сигнала тревоги** - любая строка, представляющая тип сигнала тревоги
- **Серьезность тревоги** - {CRITICAL \| MAJOR \| MINOR \| WARNING \| INDETERMINATE}
- is **Propagate** - должен ли сигнал тревоги распространяться на все родительские связанные объекты.

Примечание: узел может:

-  Читать конфигурацию сигнала тревоги из сообщения;

-  Получать тип сигнала тревоги с помощью паттерна с полями из метаданных сообщения:

    ![image](/images/user-guide/rule-engine-2-0/nodes/action-create-alarm-config-from-msg.png)

- Распространять фильтр на родительские объекты по типам отношений:

    ![image](/images/user-guide/rule-engine-2-0/nodes/action-create-alarm-propagate-list.png)

Скрипт **Alarm Details Builder** используется, чтобы сгенерировать Alarm Details JsonNode. Это нужно для хранения дополнительных параметров внутри сигнализации. Например, вы можете сохранить пару «имя/значение» атрибута из оригинальной полезной нагрузки или метаданных сообщения.

Скрипт **Alarm Details Builder** должен возвращать объект **details**.
 
![image](/images/user-guide/rule-engine-2-0/nodes/action-create-alarm-config.png)

-  Полезная нагрузка сообщения должна быть доступна через свойство <code>msg</code>. Например, <code>msg.temperature</code><br/> 
- Доступ к метаданным сообщения можно получить через свойство <code>metadata</code>. Например, <code>metadata.customerName</code><br/> 
- Тип сообщения можно получить через свойство <code>msgType</code>. Например, <code>msgType</code><br/>

**Опционально:**  предыдущие сведения о сигналах тревоги можно получить с помощью <code>metadata.prevAlarmDetails</code>. 
Если предыдущий сигнал тревоги не существует, то это поле не будет присутствовать в метаданных. **Примечание**  <code>metadata.prevAlarmDetails</code> - необработанное строковое поле, и его необходимо преобразовать в объект с помощью следующей конструкции:
{% highlight javascript %}
var details = {};
if (metadata.prevAlarmDetails) {
    details = JSON.parse(metadata.prevAlarmDetails);
}
{% endhighlight %}

Функция скрипта **Alarm Details Builder** может быть проверена с помощью [тестовой функции JavaScript](/docs/user-guide/rule-engine-2-0/overview/#test-javascript-functions).
 
**Пример функции Details Builder**

Эта функция берет свойство <code>count</code> из предыдущего сигнала тревоги и увеличивает его, а также помещает атрибут <code>temperature</code> из полезной нагрузки входящего сообщения в детали сигнала тревоги.

{% highlight javascript %}
var details = {temperature: msg.temperature, count: 1};

if (metadata.prevAlarmDetails) {
    var prevDetails = JSON.parse(metadata.prevAlarmDetails);
    if(prevDetails.count) {
        details.count = prevDetails.count + 1;
    }
}

return details;
{% endhighlight %}


**Сигнал тревоги создан/обновлен с помощью этих свойств:**

- Детали тревоги - объект, возвращенный скрипта **Alarm Details Builder**
- Состояние тревоги – если **новый сигнал тревоги** -> *ACTIVE_UNACK*. Если **существующий сигнал тревоги** -> не изменяется
- Серьезность – значение из конфигурации узла
- Распространение – значение из конфигурации узла
- Тип сигнала тревоги – значение из конфигурации узла
- Время начала сигнала тревоги - если **новый сигнал тревоги** -> текущее системное время. Если **существующий сигнал тревоги** -> не изменяется
- Время окончания тревоги – *текущее системное время*

**Исходящее сообщение будет иметь следующую структуру:**

- **Тип сообщения** - *ALARM*
- **Отправитель** - из входящего сообщения
- **Полезная нагрузка** - JSON-представление нового сигнала тревоги, который был создан/обновлен
- **Метаданные** - все поля из исходных метаданных сообщения  

После создания нового сигнала тревоги исходящее сообщение будет содержать дополнительное свойство внутри метаданных - **isNewAlarm** со значением **true**. Сообщение будет передано по цепочке **Created**.

После обновления существующего сигнала тревоги исходящее сообщение будет содержать дополнительное свойство внутри метаданных – **isExistingAlarm** со значением **true**. Сообщение будет передано по цепочке **Updated**.

Вот пример **полезной нагрузки** исходящего сообщения:
{% highlight json %}
{
  "tenantId": {
    "entityType": "TENANT",
    "id": "22cd8888-5dac-11e8-bbab-ad47060c9bbb"
  },
  "type": "High Temperature Alarm",
  "originator": {
    "entityType": "DEVICE",
    "id": "11cd8777-5dac-11e8-bbab-ad55560c9ccc"
  },
  "severity": "CRITICAL",
  "status": "ACTIVE_UNACK",
  "startTs": 1526985698000,
  "endTs": 1526985698000,
  "ackTs": 0,
  "clearTs": 0,
  "details": {
    "temperature": 70,
    "ts": 1526985696000
  },
  "propagate": true,
  "id": "33cd8999-5dac-11e8-bbab-ad47060c9431",
  "createdTime": 1526985698000,
  "name": "High Temperature Alarm"
}
{% endhighlight %}

Более подробную информацию о сигналах тревоги IoT платформы Ростелеком можно найти в [этом руководстве](/docs/user-guide/alarms/)

Вы можете увидеть пример использования данного узла в следующем уроке:

- [Создание и удаление сигналов тревоги](/docs/user-guide/rule-engine-2-0/tutorials/create-clear-alarms/)

<br/>

# Узел Clear Alarm

![image](/images/user-guide/rule-engine-2-0/nodes/action-clear-alarm.png)

Этот узел загружает последний сигнал тревоги с настроенным **типом сигнала тревоги** для отправителя сообщения и очищает сигнал тревоги, если он есть.

Конфигурация Узла:

- Скрипт **Alarm Details Builder**
- **Тип сигнала тревоги** - любая строка, представляющая тип сигнала тревоги

Примечание: узел правил имеет возможность получать тип сигнала тревоги с помощью паттерна с полями из метаданных сообщения:

   ![image](/images/user-guide/rule-engine-2-0/nodes/action-clear-alarm-fetch-alarm-type-from-metadata.png)

Скрипт **Alarm Details Builder**, используется для обновления сведений о тревоге JsonNode. Он полезен для хранения дополнительных параметров внутри сигнализации. Например, вы можете сохранить пару имя/значение атрибута из исходной полезной нагрузки или метаданных сообщения.

Скрипт **Alarm Details Builder** должен возвращать объект **details**.

![image](/images/user-guide/rule-engine-2-0/nodes/action-clear-alarm-config.png)
 
- Полезная нагрузка сообщения может быть доступна через свойство <code>msg</code> property. Например, <code>msg.temperature</code><br/> 
- Метаданные сообщения могут быть доступны через свойство <code>metadata</code>. Например, <code>metadata.customerName</code><br/> 
- Тип сообщения может быть доступен через свойство <code>msgType</code>. Например, <code>msgType</code><br/>
- Текущие детали сигнала тревоги могут быть доступны через <code>metadata.prevAlarmDetails</code>. 

**Примечание**  <code>metadata.prevAlarmDetails</code> 
– это необработанное строковое поле и оно должно быть преобразовано в объект с помощью этой конструкции:
{% highlight javascript %}
var details = {};
if (metadata.prevAlarmDetails) {
    details = JSON.parse(metadata.prevAlarmDetails);
}
{% endhighlight %}

Функция скрипта **Alarm Details Builder** может быть проверена с помощью [Тестовой JavaScript функции](/docs/user-guide/rule-engine-2-0/overview/#test-javascript-functions).

**Пример функции Details Builder**

Эта функция принимает свойство <code>count</code> от предыдущего сигнала тревоги и увеличивает его, а также помещает атрибут <code>temperature</code> из полезной нагрузки входящего сообщения в детали сигнала тревоги.
{% highlight javascript %}
var details = {temperature: msg.temperature, count: 1};

if (metadata.prevAlarmDetails) {
    var prevDetails = JSON.parse(metadata.prevAlarmDetails);
    if(prevDetails.count) {
        details.count = prevDetails.count + 1;
    }
}

return details;
{% endhighlight %}

 
Этот узел обновляет текущий сигнал тревоги:

- изменение **состояния** сигнала тревоги на **CLEARED_ACK**, если оно уже было подтверждено. Если не было подтверждено – на **CLEARED_UNACK**
- установка **clear time** на текущее системное время
- обновление сведения о тревоге с помощью нового объекта, возвращенного из скрипта **Alarm Details Builder**


В случае, если сигнал тревоги не существует или он уже **удален**, исходное сообщение будет передано следующим узлам по цепочке **False**.

В противном случае новое сообщение будет передано по цепочке **Cleared**.

**Исходящее сообщение будет иметь следующую структуру:**

- **Тип сообщения** - *ALARM*
- **Отправитель** - из входящего сообщения
- **Полезная нагрузка** - JSON-представление тревоги, которая была очищена
- **Метаданные** - все поля из исходных метаданных сообщения. Также будет добавлено дополнительное свойство внутри метаданных -> **isClearedAlarm** со значением **true**.

Вот пример **полезной нагрузки** исходящего сообщения:
{% highlight json %}
{
  "tenantId": {
    "entityType": "TENANT",
    "id": "22cd8888-5dac-11e8-bbab-ad47060c9bbb"
  },
  "type": "High Temperature Alarm",
  "originator": {
    "entityType": "DEVICE",
    "id": "11cd8777-5dac-11e8-bbab-ad55560c9ccc"
  },
  "severity": "CRITICAL",
  "status": "CLEARED_UNACK",
  "startTs": 1526985698000,
  "endTs": 1526985698000,
  "ackTs": 0,
  "clearTs": 1526985712000,
  "details": {
    "temperature": 70,
    "ts": 1526985696000
  },
  "propagate": true,
  "id": "33cd8999-5dac-11e8-bbab-ad47060c9431",
  "createdTime": 1526985698000,
  "name": "High Temperature Alarm"
}
{% endhighlight %}


Более подробную информацию о сигналах тревоги можно найти в  [следующем руководстве](/docs/user-guide/alarms/)

Вы можете увидеть пример, где используется данный узел в руководстве:

- [Создание и удаление сигналов тревоги](/docs/user-guide/rule-engine-2-0/tutorials/create-clear-alarms/)

<br/>

# Узел Delay

![image](/images/user-guide/rule-engine-2-0/nodes/action-delay.png)

Задерживает входящие сообщения на настраиваемый период.

Конфигурация:

![image](/images/user-guide/rule-engine-2-0/nodes/action-delay-config.png)

- **Период в секундах** - указывает значение периода, в течение которого входящее сообщение должно быть отложено
- **Максимальное количество отложенных сообщений** - задает количество максимально допустимых отложенных сообщений (очередь приостановленных сообщений)

Когда истечет период задержки для конкретного входящего сообщения, оно будет удалено из очереди ожидания и перенаправлено на следующие узлы по цепочке **Success**.

Каждое следующее сообщение будет перенаправляться по цепочке **Failure**, если будет достигнут предел ожидающих сообщений.

<br/>

# Узел Generator

![image](/images/user-guide/rule-engine-2-0/nodes/action-generator.png)

Генерирует сообщения с настраиваемым периодом. Для генерации сообщений используется функция JavaScript.

Конфигурация узла:

- Частота генерации сообщений в секундах
- Отправитель сообщения 
- Функция JavaScript, которая будет генерировать фактическое сообщение.

Функция JavaScript получает 3 входных параметра:

- <code>prevMsg</code> - ранее сгенерированная полезная нагрузка сообщения.
- <code>prevMetadata</code> - ранее сгенерированные метаданные сообщения.
- <code>prevMsgType</code> - ранее сгенерированный тип сообщения.

Скрипт должен возвращать следующую структуру:
{% highlight java %}
{   
    msg: new payload,
    metadata: new metadata,
    msgType: new msgType 
}
{% endhighlight %}

![image](/images/user-guide/rule-engine-2-0/nodes/action-generator-config.png)

Все поля в итоговом объекте являются необязательными и будут взяты из ранее сгенерированного сообщения, если они не указаны.

Сообщение, исходящее от этого узла, будет новым, построенным с использованием настроенной функции JavaScript.

Функция генератора JavaScript может быть проверена с помощью [Тестовой функции JavaScript](/docs/user-guide/rule-engine-2-0/overview/#test-javascript-functions).

Этот узел можно использовать для отладки цепочка правил.

<br/>

# Узел Log 

![image](/images/user-guide/rule-engine-2-0/nodes/action-log.png)

Преобразуйте входящее сообщение с помощью настроенной функции JavaScript в строку и записывайте конечное значение в файл журнала.

Уровень логирования **INFO** используется для логирования.

Функция JavaScript получает 3 входных параметра

- <code>metadata</code> - метаданные сообщения.
- <code>msg</code> - полезная нагрузка сообщения.
- <code>msgType</code> - тип сообщения.

Скрипт должен возвращать строковое значение.

![image](/images/user-guide/rule-engine-2-0/nodes/action-log-config.png)

Функция преобразования JavaScript может быть проверена с помощью [Тестовой функции JavaScript](/docs/user-guide/rule-engine-2-0/overview/#test-javascript-functions).

Пример использования данного узла вы можете увидеть в следующем руководстве:

- [Ответы на вызовы RPC](/docs/user-guide/rule-engine-2-0/tutorials/rpc-reply-tutorial.md#log-unknown-request)

# Узел RPC Call Reply

![image](/images/user-guide/rule-engine-2-0/nodes/action-rpc-call-reply.png)

Отправляет ответ инициатору RPC- вызова. Все входящие RPC-запросы передаются через цепочку правил в виде сообщений. Кроме того, все RPC- запросы имеют поле request ID. Оно используется для сопоставления запросов и ответов. Составитель сообщения должен быть сущностью **устройство**, поскольку RPC-ответ инициируется отправителем сообщения.

Конфигурация узла имеет специальное сопоставление полей request ID. Если сопоставление не указано, по умолчанию используется поле метаданных **requestId**.

![image](/images/user-guide/rule-engine-2-0/nodes/action-rpc-call-reply-config.png)

RPC- запрос может быть получен с помощью различных транспортных протоколов:

- MQTT
- HTTP
- CoAP  

Пример полезной нагрузки сообщения:
{% highlight json %}
{
  "method": "setGpio",
  "params": {
    "pin": "23",
    "value": 1
  }
}
{% endhighlight %}

Сообщение будет перенаправлено по цепочке **Failure** в следующих случаях:

- Отправитель входящего сообщения не является cущностью **устройство**
- Идентификатор запроса отсутствует в метаданных сообщения
- В полезной нагрузке входящего сообщения отсутствуют данные

Для получения более подробной информации о том, как RPC работает в IoT платформе Ростелеком, прочитайте статью о [Возможностях RPC](/docs/user-guide/rpc/).

Пример использования данного узла можно увидеть в следующем руководстве:

- [Ответы на RPC-вызовы](/docs/user-guide/rule-engine-2-0/tutorials/rpc-reply-tutorial.md)

# Узел RPC Call Request

![image](/images/user-guide/rule-engine-2-0/nodes/action-rpc-call-request.png)

Отправляет RPC-запросы на устройство и маршрутизирует ответ на следующие узлы правил. Составитель сообщения должен быть сущностью **устройство**, а RPC-запрос может быть инициирован только для устройства.

Конфигурация узла имеет поле **Timeout**, которое используется для указания тайм-аута ожидания ответа от устройства.

![image](/images/user-guide/rule-engine-2-0/nodes/action-rpc-call-request-config.png)

Полезная нагрузка сообщения должна иметь соответствующий RPC-запросу формат и содержать поля **method** и **params**. Пример:
Example:

{% highlight json %}
{
  "method": "setGpio",
  "params": {
    "pin": "23",
    "value": 1
  }
}
{% endhighlight %}

Если полезная нагрузка сообщения содержит поле **requestId**, то его значение используется для идентификации RPC-запроса к устройству. В противном случае будет сгенерирован случайный requestId.

Исходящее сообщение будет иметь тот же инициатор и метаданные, что и входящее. Ответ от устройства будет добавлен в payload сообщения.

Сообщение будет перенаправлено по цепочке **Failure** в следующих случаях:

- Отправитель сообщения не является сущностью типа **Устройство**
- Во входящем сообщении отсутствуют поле **method** или **params**
- Если узел не получает ответа до настроенного таймаута
 
В противном случае сообщение будет перенаправлено по цепочке **Success**.

Для получения более подробной информации о работе RPC можно перейти на [следующую страницу](/docs/user-guide/rpc/).

<br/>

# Узел Save Attributes

<table  style="width:12%">
   <thead>
     <tr>
     <td style="text-align: center"><strong><em>С версии IoT платформы Ростелеком 2.0</em></strong></td>
     </tr>
   </thead>
</table> 

![image](/images/user-guide/rule-engine-2-0/nodes/action-save-attributes.png)

Хранит атрибуты из полезную нагрузку входящего сообщения в базе данных и связывает их с сущностью, которая идентифицируется отправителем сообщения. Настроенная **область действия** используется для идентификации области атрибутов.

Поддерживаемые типы области применения:

- Клиентские атрибуты
- Общие атрибуты
- Серверные атрибуты

![image](/images/user-guide/rule-engine-2-0/nodes/action-save-attributes-config.png)

Ожидает сообщения с типом **POST_ATTRIBUTES_REQUEST**.
Если тип сообщения не **POST_ATTRIBUTES_REQUEST**, сообщение будет направлено по цепочке **Failure**. 

Когда атрибуты загружаются через существующий API (HTTP / MQTT / CoAP / etc.) cообщение с корректной полезной нагрузкой и типом будет передано в узел **Input**, находящемся в **Root Rule Chain**.

В тех случаях, когда требуется инициировать сохранение атрибутов внутри цепочки правил, она должна быть настроена для преобразования payload сообщения в ожидаемый формат и тип сообщения **POST_ATTRIBUTES_REQUEST**. Это можно было бы сделать с помощью [**Узла Script Transformation**](/docs/user-guide/rule-engine-2-0/transformation-nodes/#script-transformation-node).

**Пример ожидаемой полезной нагрузки:**
{% highlight json %}
{
  "firmware_version": "1.0.1",
  "serial_number": "SN-001"
}
{% endhighlight %}

После успешного сохранения атрибутов исходное сообщение будет передано следующим узлам через цепочку **Success**, в противном случае используется цепочка **Failure**.

<br/>

# Узел Save Timeseries 

![image](/images/user-guide/rule-engine-2-0/nodes/action-save-timeseries.png)

Хранит данные временных рядов из payload входящего сообщения в базе данных и связывает их с сущностью, идентифицируемой отправителем сообщения. Сконфигурированный **TTL** секунд используется для истечения срока действия данных timeseries. Значение **0** означает, что срок действия данных никогда не истечет.

![image](/images/user-guide/rule-engine-2-0/nodes/action-save-timeseries-config.png)

Ожидает сообщения типа **POST_TELEMETRY_REQUEST**. 
Если тип сообщения не является **POST_TELEMETRY_REQUEST**, то сообщение направляется по цепочке **Failure**.
 
Когда данные временных рядов публикуются через существующий API (HTTP / MQTT / CoAP / etc.), сообщение с правильной полезной нагрузкой и типом будет передано в узел **Input**, который находится в **Root Rule Chain**.

В тех случаях, когда требуется инициировать сохранение данных временных рядов внутри цепочки правил, цепочка правил должна быть сконфигурирована для преобразования payload сообщения
к ожидаемому формату и установите тип сообщения в **POST_TELEMETRY_REQUEST**. Это можно было бы сделать с помощью Узла [**Узла Script Transformation**](/docs/user-guide/rule-engine-2-0/transformation-nodes/#script-transformation-node).

Метаданные сообщения должны содержать поле **ts**. Это поле определяет метку времени в миллисекундах опубликованной телеметрии.

Кроме того, если метаданные сообщения содержат поле **TTL**, его значение используется для истечения срока действия данных временных рядов, в противном случае **TTL** из конфигурации узла используется.

**Пример ожидаемой полезной нагрузки сообщения**
{% highlight json %}
{  
  "values": {
    "key1": "value1",
    "key2": "value2"
  }
}
{% endhighlight %}

После успешного сохранения данных временных рядов исходное сообщение будет передано следующим узлам по цепочке **Success**, иначе используется цепочка **Failure**.

<br/>

# Save to Custom Table

![image](/images/user-guide/rule-engine-2-0/nodes/action-save-to-custom-cassandra-table.png)

Узел хранит данные из payload входящего сообщения в базе данных Cassandra в заведомо определенной пользовательской таблице, которая должна иметь префикс **cs_tb_**, чтобы избежать вставки данных в общие таблицы IoT Ростелеком.

Обратите внимание, что узел правил может использоваться только для базы данных **Cassandra DB**.

Конфигурация:

Администратор должен установить пользовательское имя таблицы без префикса: **cs_tb_**.

![image](/images/user-guide/rule-engine-2-0/nodes/action-save-to-custom-cassandra-table-name-config.png)

Администратор может настроить сопоставление наименований полей в сообщениях и столбцов таблицы. Если ключом сопоставления является **$entity_id**, который идентифицируется составителем сообщения, то в соответствующий столбец name (mapping value) будет записан идентификатор составителя сообщения.

![image](/images/user-guide/rule-engine-2-0/nodes/action-save-to-custom-cassandra-table-config.png)

Если указанное поле сообщения не существует или не является примитивом JSON, исходящее сообщение будет маршрутизировано через цепочку **Failure**, в противном случае сообщение будет маршрутизировано через цепочку **Success**.

<br/>

# Узел Assign To Customer 

![image](/images/user-guide/rule-engine-2-0/nodes/action-assign-to-customer-node.png)

 Назначает сущность отправителя сообщения [клиенту](/docs/user-guide/ui/customers/).
 
 Допускаются следующие типы отправителей сообщений: **Актив**, **Устройство**, **Представление сущности**, **Дашборд**.

Находит целевого клиента по паттерну имени клиента, а затем назначает этому клиенту сущность-инициатор.

Создаст нового клиента, если его нет и **Create customer if not exists** имеет значение **true**.

Конфигурация:

![image](/images/user-guide/rule-engine-2-0/nodes/action-assign-to-customer-node-configuration.png)

- **Шаблон имени клиента** - можно установить прямое имя клиента или использовать паттерн, который будет применен к реальному имени клиента с помощью метаданных сообщения.
- **Создать нового клиента, если его нет** - если флажок установлен, то будет создан новый клиент.
- **Время истечения срока действия кэша клиентов** - указывает максимальный интервал времени в секундах, отведенный для хранения найденных записей клиентов. Значение 0 означает, что срок действия записей никогда не истечет.

Сообщение будет перенаправлено по цепочке **Failure** в следующих случаях

- Если тип сущности-отправителя не поддерживается.
- Целевой клиент не существует и **Create customer if not exists**

В других случаях сообщение будет перенаправлено по цепочке **Success**. 

<br/>

# Узел Unassign From Customer

![image](/images/user-guide/rule-engine-2-0/nodes/action-unassign-from-customer-node.png)

Отменяет назначение сущности-отправителя сообщения [Клиенту](/docs/user-guide/ui/customers/). Допускаются следующие типы отправителей сообщений: **Актив**, **Устройство**, **Представление сущности**, **Дашборд**.

Находит целевого клиента по паттерну имени клиента, а затем отменяет назначение сущности-отправителя этому клиенту.

Конфигурация:

![image](/images/user-guide/rule-engine-2-0/nodes/action-unassign-from-customer-node-configuration.png)

- **Шаблон имени клиента** - можно установить прямое имя клиента или использовать паттерн, который будет применен к реальному имени клиента с помощью метаданных сообщения.
- **Время истечения срока действия кэша клиентов** - указывает максимальный интервал времени в секундах, отведенный для хранения найденных записей клиентов. Значение 0 означает, что срок действия записей никогда не истечет.

Сообщение будет направлено по цепочке **Failure** в следующих случаях:

- Если тип сущности-отправителя не поддерживается.
- Целевой клиент не существует.

В других случаях сообщение будет направлено по цепочке **Success**. 

<br/>

# Узел Create Relation 

![image](/images/user-guide/rule-engine-2-0/nodes/action-create-relation.png)

Создает отношение между выбранным объектом и отправителем сообщения по типу и направлению.

Допускаются следующие типы отправителей сообщений: **Актив**, **Устройство**, **Представление сущности**, **Клиент**, **Тенант**, **Дашборд**.

Находит целевую сущность по паттернам ключей метаданных, а затем создает связь между сущностью-отправителем и целевой сущностью.

Если выбран тип сущности **Актив**, **Устройство** или **Клиент**,  узел правил устройства или клиента создаст новую сущность, если её нет, и установлен флажок **Create new Entity if not exists**.

**Примечание:** если выбран тип сущности **Актив** или **Устройство**, вам необходимо установить два шаблона:

 - шаблон имени сущности; 
 
 - шаблон типа сущности. 

В противном случае должен быть установлен только шаблон имени.

Конфигурация:

![image](/images/user-guide/rule-engine-2-0/nodes/action-create-relation-node-configuration.png)

- **Направление** - разрешены следующие типы: **From**, **To**.
- **Тип отношений** - тип направленных соединений с сущностью-инициатором сообщения. Типы по умолчанию **Contains** и **Manages** можно выбрать из раскрывающегося списка.
- **Шаблон имени** и **Шаблон типа** - можно задать прямое имя сущности/тип или использовать паттерн, который будет применен к реальному имени сущности/типу с помощью метаданных сообщения.
- **Время истечения срока действия кэша сущностей** - указывает максимальный интервал времени в секундах, отведенный для хранения найденных записей целевых сущностей. Значение 0 означает, что срок действия записей никогда не истечет.

Сообщение будет направлено по цепочке **Failure** в следующих:

- Если тип сущности-отправителя не поддерживается.
- Целевой объект не существует.

В других случаях сообщение будет направлено по цепочке **Success**. 

**Примечание:** начиная с версии IoT платформы Ростелеком 2.3, узел правил имеет возможность:

 - удалить текущие отношения отправителя входящего сообщения на основе направления и типа:

    ![image](/images/user-guide/rule-engine-2-0/nodes/action-create-relation-node-remove-relations.png)

 - изменить отправителя входящего сообщения на выбранную сущность и обработать исходящие сообщения как сообщения от другой сущности: 
 
    ![image](/images/user-guide/rule-engine-2-0/nodes/action-create-relation-node-change-originator.png)

<br/>

# Узел Delete Relation


![image](/images/user-guide/rule-engine-2-0/nodes/action-delete-relation.png)

Удаляет связь между выбранным объектом и отправителем сообщения по типу и направлению.

Допускаются следующие типы отправителей сообщений: **Актив**, **Устройство**, **Представление сущности**, **Клиент**, **Тенант**, **Дашборд**.

Находит целевую сущность по паттерну имени сущности, а затем удаляет связь между сущностью-инициатором и этой сущностью.

Конфигурация:

![image](/images/user-guide/rule-engine-2-0/nodes/action-delete-relation-node-configuration.png)

- **Направление** - разрешены следующие типы: **From**, **To**.
- **Тип отношений** - тип направленных соединений с сущностью-инициатором сообщения. Типы по умолчанию **Contains** и **Manages** можно выбрать из раскрывающегося списка.
- **Шаблон имени** - может быть задано прямое имя сущности или использован паттерн, который будет применен к реальному имени сущности с помощью метаданных сообщения.
- **Время истечения срока действия кэша сущностей** - указывает максимальный интервал времени в секундах, разрешенный для хранения найденных записей целевых сущностей. Значение 0 означает, что срок действия записей никогда не истечет.

Сообщение будет направлено по цепочке **Failure** в следующих случаях:

- Если тип сущности-отправителя не поддерживается.
- Целевая сущность не существует.

В остальных случаях сообщение будет направлено по цепочке **Success**. 


**Примечание:** начиная с версии в IoT Ростелеком 2.3, есть возможность удалить связь между отправителем входящего сообщения и указанным объектом или их группой на основе направления и типа, отключив следующий флажок в настройках узла правил:

![image](/images/user-guide/rule-engine-2-0/nodes/action-delete-relation-node-new-functionality.png)

<br/>

# Узел GPS Geofencing Events

![image](/images/user-guide/rule-engine-2-0/nodes/action-gps-geofencing-event-node.png)

Производит входящие сообщения GPS based-параметрам. Извлекает широту и долготу из данных входящих сообщений или метаданных и возвращает различные события на основе параметров конфигурации (geo fence).

![image](/images/user-guide/rule-engine-2-0/nodes/filter-gps-geofencing-default-config.png)

Узел правил по умолчанию извлекает информацию о периметре из метаданных сообщений. Если флажок **Извлекать информацию о периметре из метаданных сообщений** снят, необходимо настроить дополнительные сведения.

<br>

###### Извлечение информации о периметре из метаданных сообщений

Существует два варианта определения площади в зависимости от типа периметра:

- Полигон 
           
    Метаданные входящего сообщения должны включать ключ с именем **perimeter** и следующую структуру данных:
     
{% highlight java %}[[lat1,lon1],[lat2,lon2], ... ,[latN,lonN]]{% endhighlight %}
 
- Круг
                 
{% highlight java %}"centerLatitude": "value1", "centerLongitude": "value2", "range": "value3"

Все значения для этих ключей имеют тип данных двойной точности с floating-point.

The "rangeUnit" key requires specific value from a list of METER, KILOMETER, FOOT, MILE, NAUTICAL_MILE (capital letters obligatory).
{% endhighlight %}

###### Извлечение информации о периметре из конфигурации узла
 
Существует два варианта определения площади в зависимости от типа периметра:

- Полигон 
             
![image](/images/user-guide/rule-engine-2-0/nodes/filter-gps-geofencing-polygon-config.png)           

- Круг
                  
![image](/images/user-guide/rule-engine-2-0/nodes/filter-gps-geofencing-circle-config.png)       

###### Типы событий
Существует 4 типа событий управляемых узлом правил геозоны:

- **Entered** — сообщается всякий раз, когда широта и долгота из входящего сообщения присваиваются требуемой площади периметра впервые;
- **Left** — сообщается всякий раз, когда широта и долгота из входящего сообщения присваиваются требуемой площади периметра не в первый раз;
- **Inside** и **Outside** события используются для отчета о текущем состоянии.

Администратор может настроить порог продолжительности для создания отчетов о внутренних или внешних событиях. Например, когда минимальное внутреннее время равно 1 минуте, отправитель сообщения считается находящимся внутри периметра через 60 секунд после входа в зону. 
Минимальное внешнее время определяет, когда отправитель сообщения считается вышедшим за периметр.

![image](/images/user-guide/rule-engine-2-0/nodes/action-gps-geofencing-event-node-duration-config.png)  
 
Цепочка **Failure** будет использоваться, когда:

   - входящее сообщение не имеет выставленных значений широты или долготы в данных или метаданных
   - отсутствует значение периметра
    
